# -*- coding: utf-8 -*-
"""Copy of Untitled

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PuD6V0_XSeWjGCViF2U8bG_IuacZF1Ca
"""
import matplotlib.pyplot as plt
from keras.utils import to_categorical
from cnn.neural_network import NeuralNetworkArchitectures
from cnn.c_neural_network import CNN
from sklearn.model_selection import KFold
from sklearn.metrics import classification_report, accuracy_score
import cv2
import random
import itertools
import numpy as np
from sklearn.model_selection import train_test_split
import os


shape = ()
dimension = 0
pixel = 0
Data = []
x = []
y = []


def preprocessDataSet(imgType, networkType):
    categories = []
    directory = "D:\python\cnn\Sign-Language-Digits-Dataset\Dataset"
    categories.append(os.listdir(directory))
    categories = list(itertools.chain.from_iterable(categories))
    for category in categories:
        path = os.path.join(directory, category)
        classNumber = categories.index(category)
        for image in os.listdir(path):
            if imgType == "gray":
                img = cv2.imread(os.path.join(path, image), cv2.IMREAD_GRAYSCALE)
                normalizedImage = cv2.resize(img, (pixel, pixel))
                Data.append([normalizedImage, classNumber])
            else:
                img = cv2.imread(os.path.join(path, image))
                #average = np.average(img)
                #newImg = np.subtract(average, img)
                normalizedImage = cv2.resize(img, (pixel, pixel))
                Data.append([normalizedImage, classNumber])


def partitionData(type, x):
    random.shuffle(Data)
    images = []
    classes = []
    for imageArray, label in Data :
        images.append(imageArray)
        classes.append(label)   

    if x == "color":
        flattenedImages = np.array(images).flatten()
        mean = np.mean(flattenedImages)
        images = np.subtract(images, mean)
    if type != "nn":
        images = np.array(images).reshape(-1, 50, 50, dimension)
    else:
        images = np.array(images).astype(float)
    images = images/255.0

    return images, classes


if __name__ == "__main__":
    networkType = input()
    imageType = input()
    nnModule = None
    if networkType == "convo":
        numberOfEpochs = 5
        pixel = 50
        if imageType == "gray":
            nnModule=CNN((50, 50, 1))
            dimension = 1
        else:
            nnModule = CNN((50, 50, 3))
            dimension = 3

    else:
        nnModule = NeuralNetworkArchitectures((100, 100))
        numberOfEpochs = 100
        pixel = 100

    preprocessDataSet(imageType, networkType)
    x, y = partitionData(networkType, imageType)
    yNew = to_categorical(y, 10)
    X_train, X_test, Y_train, Y_test = train_test_split(x, yNew, train_size=.8, random_state=1)
    kFold = KFold(n_splits=4)
    i = 0
    file = open("rep.txt", 'a+')
    print(pixel)

    for i in range(1, 5):
        file.write("arch: " + str(i) + "\r\n")
        model = nnModule.choose(i)
        #accuracies = []
        print(i)
        for trainData, validationData in kFold.split(X_train):
            model.fit(X_train[trainData], Y_train[trainData], epochs=numberOfEpochs, validation_data=[X_train[validationData], Y_train[validationData]])
            #metrics = model.evaluate(X_train[validationData], Y_train[validationData])

        yPrediction = model.predict_classes(X_test)

        file.write(str(classification_report(np.argmax(Y_test, axis=1), yPrediction)) + "\r\n")
        file.write(str(accuracy_score(np.argmax(Y_test, axis=1), yPrediction)) + "\r\n")
        #model.save("64x3-CNN.model")
    file.close()

#for each